package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"slices"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	srcFileName   = "../ptr.go"
	codeGenHeader = "// type wrapper code generated by ./generated/main.go\n"
)

type supportedTypes struct {
	name     string
	dataType string
}

var (
	types = []supportedTypes{
		{"string", "string"},
		{"byte", "byte"},
		{"bool", "bool"},
		{"int", "int"},
		{"int8", "int8"},
		{"int16", "int16"},
		{"int32", "int32"},
		{"int64", "int64"},
		{"uint8", "uint8"},
		{"uint16", "uint16"},
		{"uint32", "uint32"},
		{"uint64", "uint64"},
		{"float32", "float32"},
		{"float64", "float64"},
		{"time", "time.Time"},
	}

	capitalize = cases.Title(language.AmericanEnglish)

	codeGenHeaderBytes = []byte(codeGenHeader)
)

func main() {
	src, err := os.ReadFile(srcFileName)
	if err != nil {
		log.Fatalf("unable to open '%s': %v\n", srcFileName, err)
	}

	headerIndex := bytes.Index(src, codeGenHeaderBytes)

	if headerIndex != -1 {
		src = bytes.Split(src, codeGenHeaderBytes)[0]
	}

	codeGen := codeGenHeader

	for _, t := range types {
		codeGen += ptr(t)
		codeGen += ptrSlice(t)
		codeGen += ptrMap(t)
		codeGen += value(t)
		codeGen += valueSlice(t)
		codeGen += valueMap(t)
	}

	src = slices.Concat(src, []byte(codeGen))

	err = os.WriteFile(srcFileName, src, os.ModeAppend)
	if err != nil {
		log.Fatalf("failed to write generated code: %v\n", err)
	}
	log.Printf("generated code for supported types: %v\n", types)
}

func ptr(t supportedTypes) string {
	return fmt.Sprintf(`func %s(v %s) *%s {
	return Ptr(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func ptrSlice(t supportedTypes) string {
	return fmt.Sprintf(`func %sSlice(v []%s) []*%s {
	return PtrSlice(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func ptrMap(t supportedTypes) string {
	return fmt.Sprintf(`func %sMap(v map[string]%s) map[string]*%s {
	return PtrMap(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}

func value(t supportedTypes) string {
	return fmt.Sprintf(`func %sValue(v *%s) %s {
	return Value(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func valueSlice(t supportedTypes) string {
	return fmt.Sprintf(`func %sValueSlice(v []*%s) []%s {
	return ValueSlice(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func valueMap(t supportedTypes) string {
	return fmt.Sprintf(`func %sValueMap(v map[string]*%s) map[string]%s {
	return ValueMap(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
