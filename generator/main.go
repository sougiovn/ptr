package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"slices"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	srcFileName   = "../ptr.go"
	testFileName  = "../ptr_test.go"
	codeGenHeader = "// type wrapper code generated by ./generated/main.go\n"
)

type supportedTypes struct {
	name     string
	dataType string
}

var (
	types = []supportedTypes{
		{"string", "string"},
		{"byte", "byte"},
		{"bool", "bool"},
		{"int", "int"},
		{"int8", "int8"},
		{"int16", "int16"},
		{"int32", "int32"},
		{"int64", "int64"},
		{"uint8", "uint8"},
		{"uint16", "uint16"},
		{"uint32", "uint32"},
		{"uint64", "uint64"},
		{"float32", "float32"},
		{"float64", "float64"},
		{"time", "time.Time"},
	}

	capitalize = cases.Title(language.AmericanEnglish)

	codeGenHeaderBytes = []byte(codeGenHeader)
)

func main() {
	err := genSrc()
	if err != nil {
		log.Fatalf("unable to generate type wrappers in source code: %v\n", err)
	}
	log.Printf("generated code for supported types: %v\n", types)

	err = genTest()
	if err != nil {
		log.Fatalf("unable to generate test for type wrappers in source code: %v\n", err)
	}
	log.Printf("generated code for test supported types: %v\n", types)
}

func genSrc() error {
	src, err := os.ReadFile(srcFileName)
	if err != nil {
		return fmt.Errorf("unable to open source file '%s': %v", srcFileName, err)
	}

	headerIndex := bytes.Index(src, codeGenHeaderBytes)

	if headerIndex != -1 {
		src = bytes.Split(src, codeGenHeaderBytes)[0]
	}

	codeGen := codeGenHeader

	for _, t := range types {
		codeGen += to(t)
		codeGen += toSlice(t)
		codeGen += toMap(t)
		codeGen += value(t)
		codeGen += valueSlice(t)
		codeGen += valueMap(t)
	}

	src = slices.Concat(src, []byte(codeGen))

	err = os.WriteFile(srcFileName, src, os.ModeAppend)
	if err != nil {
		return fmt.Errorf("unable to write type wrapper to source file '%s': %v", srcFileName, err)
	}
	return nil
}

func to(t supportedTypes) string {
	return fmt.Sprintf(`func %s(v %s) *%s {
	return To(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func toSlice(t supportedTypes) string {
	return fmt.Sprintf(`func %sSlice(v []%s) []*%s {
	return ToSlice(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func toMap(t supportedTypes) string {
	return fmt.Sprintf(`func %sMap(v map[string]%s) map[string]*%s {
	return ToMap(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}

func value(t supportedTypes) string {
	return fmt.Sprintf(`func %sValue(v *%s) %s {
	return Value(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func valueSlice(t supportedTypes) string {
	return fmt.Sprintf(`func %sValueSlice(v []*%s) []%s {
	return ValueSlice(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}
func valueMap(t supportedTypes) string {
	return fmt.Sprintf(`func %sValueMap(v map[string]*%s) map[string]%s {
	return ValueMap(v)
}
`,
		capitalize.String(t.name),
		t.dataType,
		t.dataType,
	)
}

func genTest() error {
	src, err := os.ReadFile(testFileName)
	if err != nil {
		return fmt.Errorf("unable to open test file '%s': %v", srcFileName, err)
	}

	headerIndex := bytes.Index(src, codeGenHeaderBytes)

	if headerIndex != -1 {
		src = bytes.Split(src, codeGenHeaderBytes)[0]
	}

	codeGen := codeGenHeader

	for _, t := range types {
		if strings.Contains(t.dataType, "int") || strings.Contains(t.dataType, "float") || strings.Contains(t.dataType, "byte") {
			codeGen += testToIntFloatAndByte(t)
			codeGen += testValueIntFloatAndByte(t)
		}
	}

	src = slices.Concat(src, []byte(codeGen))

	err = os.WriteFile(testFileName, src, os.ModeAppend)
	if err != nil {
		return fmt.Errorf("unable to write test for type wrappers to test file '%s': %v", testFileName, err)
	}
	return nil
}

func testToIntFloatAndByte(t supportedTypes) string {
	capitalized := capitalize.String(t.name)
	return fmt.Sprintf(`func Test_%s(t *testing.T) {
	t.Run("%s", func(t *testing.T) {
		value := %s(42)

		pointer := %s(value)
		assert.Equal(t, value, *pointer)
	})

	t.Run("%s/slice", func(t *testing.T) {
		value := []%s{%s(42), %s(69), %s(99)}

		pointer := %sSlice(value)
		require.Len(t, pointer, len(value))
		for i := range value {
			assert.Equal(t, value[i], *pointer[i])
		}
	})

	t.Run("%s/map", func(t *testing.T) {
		value := map[string]%s{
			"foo": %s(42), 
			"bar": %s(69), 
			"baz": %s(99),
		}

		pointer := %sMap(value)
		require.Len(t, pointer, len(value))
		for i := range value {
			assert.Equal(t, value[i], *pointer[i])
		}
	})
}
`,
		capitalized,

		t.dataType,
		t.dataType,
		capitalized,

		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		capitalized,

		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		capitalized,
	)
}

func testValueIntFloatAndByte(t supportedTypes) string {
	capitalized := capitalize.String(t.name)
	return fmt.Sprintf(`func Test_%sValue(t *testing.T) {
	t.Run("%s", func(t *testing.T) {
		pointer := %s(42)

		value := %sValue(&pointer)
		assert.Equal(t, pointer, value)
	})

	t.Run("%s/slice", func(t *testing.T) {
		p1 := %s(42)
		p2 := %s(69)
		p3 := %s(99)
		pointer := []*%s{&p1, &p2, &p3}

		value := %sValueSlice(pointer)
		require.Len(t, value, len(pointer))
		for i := range pointer {
			assert.Equal(t, *pointer[i], value[i])
		}
	})

	t.Run("%s/map", func(t *testing.T) {
		p1 := %s(42)
		p2 := %s(69)
		p3 := %s(99)
		pointer := map[string]*%s{
			"foo": &p1, 
			"bar": &p2, 
			"baz": &p3,
		}

		value := %sValueMap(pointer)
		require.Len(t, value, len(pointer))
		for i := range pointer {
			assert.Equal(t, *pointer[i], value[i])
		}
	})
}
`,
		capitalized,

		t.dataType,
		t.dataType,
		capitalized,

		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		capitalized,

		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		t.dataType,
		capitalized,
	)
}
